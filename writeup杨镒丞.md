# FDUCTF Writeup

## baby64

对输入进行 encode 后与 YnQ0Z2Qnf111bX4eNWMeaiA1W2QpYU8nbWJycE9xanU8Dh 进行比较，encode 过程类似 base64，但进行了一些位的置换，解密脚本如下
```python
table_row = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
table = []
encoded_str = "YnQ0Z2Qnf111bX4eNWMeaiA1W2QpYU8nbWJycE9xanU8Dh=="

for i in range(0, 63, 2):
    table.append(table_row[i+1])
    table.append(table_row[i])
table = "".join(table)

for i in range(0, len(encoded_str), 4):
    v13 = table.find(encoded_str[i+0])
    v14 = table.find(encoded_str[i+1])
    v15 = table.find(encoded_str[i+2])
    v16 = table.find(encoded_str[i+3])
    
    v17 = (v13 << 2) + ((v14 >> 4) & 0x3)
    v18 = ((v14 & 0xf) << 4) + ((v15 >> 2) & 0xf)
    v19 = v16 + ((v15 & 0x3) << 6)

    print(chr(v17), chr(v18), chr(v19), sep="", end="")

print("")
```

## CSharpReverse

~~首先安装运行库~~，C#程序直接扔进 dnSpy 里面，注意到 `textBox1` 的 `TextChanged` 事件处理中会通过 `CheckText` 进行判定，
```C#
public bool CheckText()
{
    string text = "hd3Q2fyvrbEfAr_}r{utcsc_!d4qeseAp";
    Random random = new Random(33554432);
    text = new string((from c in text
    orderby random.Next()
    select c).ToArray<char>());
    return this.textBox1.Text == text;
}
```
直接下断点检查结果即可。

## easy_python

题目给出python 3.11的字节码文件，通过 [https://pylingual.io]() 还原源代码
```py
def mm(key):
    N = 256
    s = list(range(N))
    j = 0
    key_length = len(key)
    for i in range(N):
        j = (j + s[i] + key[i % key_length]) % N
        s[i], s[j] = (s[j], s[i])
    return s

def nn(s, data):
    i = j = 0
    N = 256
    result = []
    for byte in data:
        i = (i + 1) % N
        j = (j + s[i]) % N
        s[i], s[j] = (s[j], s[i])
        k = s[(s[i] + s[j]) % N]
        result.append(byte ^ k)
    return bytes(result)

def solve():
    key = b'FDUCTF{2024}'
    chcek_data = bytes.fromhex('f9ecf8f97b8f96baecc607004ec26724623cee86ece84a4581f8c063')
    s = mm(key)
    encrypted_data = nn(s, chcek_data)
    print(encrypted_data)

def chall():
    key = b'FDUCTF{2024}'
    flag = input('Please input the flag: ').encode()
    chcek_data = bytes.fromhex('f9ecf8f97b8f96baecc607004ec26724623cee86ece84a4581f8c063')
    s = mm(key)
    encrypted_data = nn(s, flag)
    if encrypted_data == chcek_data:
        print('Congratulations! You got the flag!')
    else:
        print('Sorry, the flag is not correct!')
if __name__ == '__main__':
    #chall()
    solve()
```
因为这个加密看起来就很可逆，直接把 check_data 扔进去求解即可。

## ezAndroid

扔进 jeb 中，发现相关逻辑都在链接库里，apk 中没什么重要的，`liblab11_warmup.so` 中 `Java_com_example_lab11_1warmup_MainActivity_Check` 负责字符串的校验，
逻辑比较简单，写个脚本还原
```py
val = 0x6E55665F73315F33723070
xor = 0x0505050505050505050505
print(bytes.fromhex(hex(val ^ xor)[2:]).decode())
```
（记得匹配端序，别交反了）

## functions

程序中有一个花里胡哨的判断，用angr解一下就可以
```py
import angr
import sys

path_to_binary = "./functions"
project = angr.Project(path_to_binary)
initial_state = project.factory.entry_state(
    add_options = { angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,
                    angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS}
)
simulation = project.factory.simgr(initial_state)

def is_successful(state):
    stdout_output = state.posix.dumps(sys.stdout.fileno())
    return str(stdout_output).count("Correct") > 0

def should_abort(state):
    stdout_output = state.posix.dumps(sys.stdout.fileno())
    return str(stdout_output).count("Incorrect") > 0

simulation.explore(find=is_successful, avoid=should_abort)

if simulation.found:
    solution_state = simulation.found[0]
    print(solution_state.posix.dumps(sys.stdin.fileno()))
else:
    raise Exception('Could not find the solution')
```

## GoGoGo

一个 Go 语言的题目，主要逻辑在 main 包的 Main、MAIN、main、main_func1 中，比较友好的一点是有多个 WRONG 的类型并且会输出，所以可以一步一步求解并验证
是否正确。难点在于最后是通过 map 进行的字符置换，可以暴力运行程序获取 map 的构造，再结合 fductf{} 已知的部分，就可以用 z3 完整解出 flag，脚本如下。
```py
from typing import List
from z3 import *

a: List[ArithRef] = Ints('a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16 a17')
solver = Solver()

# add wrong1
for i in range(0, 18):
    solver.add(a[i] > 0, a[i] < 128)
print("WRONG1:", solver.check())

# add wrong2
solver.add(a[11] == 110)
solver.add(a[17] == 97)
solver.add(a[6]  == 100)
solver.add(a[1]  == 117)
solver.add(a[3]  == 102)
print("WRONG2:", solver.check())

# add wrong3
solver.add(a[0] == 7)
solver.add(a[2] == 10)
solver.add(a[4] == 116)
solver.add(a[5] == 7)
solver.add(a[12] == a[0] * a[15])
print("WRONG3:", solver.check())

# add wrong4
solver.add(a[7] + a[8] + a[11] + a[16] == 360)
solver.add(a[7]*2 + a[8]*2 + a[11]*3 + a[16]*4 == 1080)
solver.add(a[7] - a[11]*3 - a[8]*2 + a[16]*4 == 46)
solver.add(a[7] - a[8]*3 + a[11]*3 + a[16]*10 == 1373)
solver.add(a[8] - 16 == a[13])
solver.add(a[8] + 1 == a[9]) 
print("WRONG4:", solver.check())

# add wrong5
solver.add(a[12] == a[0])
solver.add(a[14] == a[1], a[10] == a[2])

# get result
if solver.check() == sat:
    result = solver.model()
    print(result.eval(a[0]))
    print(result.eval(a[1]))
    print(result.eval(a[2]))
    print(result.eval(a[3]))
    print(result.eval(a[4]))
    print(result.eval(a[5]))
    print(result.eval(a[6]))
    print(result.eval(a[7]))
    print(result.eval(a[8]))
    print(result.eval(a[9]))
    print(result.eval(a[10]))
    print(result.eval(a[11]))
    print(result.eval(a[12]))
    print(result.eval(a[13]))
    print(result.eval(a[14]))
    print(result.eval(a[15]))
    print(result.eval(a[16]))
    print(result.eval(a[17]))
```

## maze

一个 C++ 的题目，OK函数似乎会输出flag，但感觉逆它不如走迷宫，迷宫通过 w, a, s, d 控制，分别进行相对应的 x, y 变化，只要在 521 步内走到 (56, 89) 就行了，写一个
DFS搜一搜，就能出答案啦。（PS: 想象不来这个迷宫长啥样，走法好怪）
其中一维迷宫在 init-array 中有个初始化函数，要从 IDA 里把反编译出来的代码粘贴一下。
```C++
#include <iostream>
#include <string>
using namespace std;

// v76 to v, used for pos_y%3==1
string type1Maze[] = {
    "##############################", 
    "##############################", 
    "*###***#***######*######**####", 
    "##############################", 
    "*####***#########***##########", 
    "##############################", 
    "***##***#**##*###*############", 
    "##############################", 
    "*##*#**####*******************", 
    "##############################", 
    "***#****#**######***##########", 
    "##############################", 
    "*#############################", 
    "##############################", 
    "******************##*#########", 
    "##############################", 
    "*###*###############*##*****##", 
    "##############################", 
    "*###*###############*#########", 
    "##############################", 
    "*###**********************####", 
    "##############################", 
    "****##########################", 
    "##############################", 
    "*#####**********************##", 
    "##############################", 
    "***###########################", 
    "##############################", 
    "*####################******###", 
    "##############################", 
    "*############*****########*###", 
    "##############################", 
    "*##*##*******#########***#*###", 
    "##############################", 
    "*#######################*#*###", 
    "##############################", 
    "******************######*#*###", 
    "##############################", 
    "*#######################*#*###", 
    "##############################", 
    "*##*##***********#######*#*###", 
    "##############################", 
    "*##*##*###########*#####*#*###", 
    "##############################", 
    "****##*####*****##*#####*#*###", 
    "##############################", 
    "**####*####*######*#####*#*###", 
    "##############################", 
    "**####*####**#**##*####**#*###", 
    "##############################", 
    "**####*#####*#####*#######*###", 
    "##############################", 
    "*#####*##**#*#***#**######*###", 
    "##############################", 
    "*#####*#####*###########***###", 
    "##############################", 
    "**####*#####*#################", 
    "##############################", 
    "######*#####*********#########", 
    "##############################", 
    "********######################", 
    "##############################", 
    "*#######**************##****##", 
    "##############################", 
    "*#############################"
};

// v141 to v, used for pos_y%3==0
string type0Maze[] = {
    "*#############################\n", 
    "*********#####################\n", 
    "########***************#*****#\n", 
    "########*#############*#*#####\n", 
    "#********#############*#*###*#\n", 
    "###*##################***#####\n", 
    "###*#########**********#*###*#\n", 
    "###*#################*##*#####\n", 
    "#***#################**#*###*#\n", 
    "##*##################*##*#####\n", 
    "##**#################**#***#*#\n", 
    "###*#################*########\n", 
    "##**#####**###***##*#**#####*#\n", 
    "##*###################*#######\n", 
    "##**#################**#####*#\n", 
    "###**********##*******########\n", 
    "############*#**#####****###*#\n", 
    "#######################*######\n", 
    "#####################***####*#\n", 
    "#####################*########\n", 
    "#****#######****#####***####*#\n", 
    "#######################*######\n", 
    "###################*#***####*#\n", 
    "#####################*########\n", 
    "#######**********####***####*#\n", 
    "#######################*######\n", 
    "#####################***####*#\n", 
    "#####################*########\n", 
    "#*****************###***####*#\n", 
    "######################*#######\n", 
    "#*###################**#####*#\n", 
    "#####################*########\n", 
    "#*#**#********#######****###*#\n", 
    "#####################*########\n", 
    "#*##*#*######*****###*######*#\n", 
    "#####################*########\n", 
    "#*##*#*##############******#*#\n", 
    "######****************########\n", 
    "#**#*#*#####################*#\n", 
    "######*#######################\n", 
    "####*#***********************#\n", 
    "####***#######################\n", 
    "#****#########################\n", 
    "####**########################\n", 
    "#*###*********************####\n", 
    "#*****########################\n", 
    "#*############################\n", 
    "#*############################\n", 
    "#*#####################******#\n", 
    "#*############################\n", 
    "#*****************############\n", 
    "#*############################\n", 
    "#*############################\n", 
    "#*############################\n", 
    "#***#***#***######**##########\n", 
    "###*##########################\n", 
    "#*#**######*******************\n", 
    "####*#########################\n", 
    "#**#*##*#**###*#####*#########\n", 
    "####*#########################\n", 
    "#*##*###*#########**####*#####\n", 
    "####*#########################\n", 
    "#*##**##****#############*####\n", 
    "#####****#####################\n", 
    "##############################\n"
};

// dynamic, used for pos_y%3==2
string type2Maze[] = {
    "##############################", 
    "##############################", 
    "##############################", 
    "##############################", 
    "##############################", 
    "##############################", 
    "#########*##*********#########", 
    "##############################", 
    "**#######*####################", 
    "##############################", 
    "#########*##############**####", 
    "##############################", 
    "########***##****#*###########", 
    "##############################", 
    "#**##########*##*#############", 
    "##############################", 
    "##*########*#****######*######", 
    "##############################", 
    "##*############**#############", 
    "##############################", 
    "****#######******#############", 
    "##############################", 
    "################*#*###########", 
    "##############################", 
    "######***********#############", 
    "##############################", 
    "##############################", 
    "##############################", 
    "#*****************############", 
    "##############################", 
    "#################*############", 
    "##############################", 
    "##**##*******####*####**######", 
    "##############################", 
    "##*##########*****############", 
    "##############################", 
    "##*##################*****####", 
    "##############################", 
    "#**###########################", 
    "##############################", 
    "######**********************##", 
    "##############################", 
    "#***##########################", 
    "##############################", 
    "####**********************####", 
    "##############################", 
    "##############################", 
    "##############################", 
    "######################******##", 
    "##############################", 
    "#****************#####*#######", 
    "##############################", 
    "######################*##*####", 
    "##############################", 
    "#**#*******#*#*##***#####*####", 
    "##############################", 
    "##############################", 
    "##############################", 
    "#**###*#**###############*####", 
    "##############################", 
    "#######**####*###***#####*####", 
    "##############################", 
    "####*###***##*##########*#####", 
    "##############################", 
    "##############################"
};

void initType2Maze() {
    int i = 0, offsets[51];
    offsets[0] = 68;
    offsets[1] = 69;
    offsets[2] = 70;
    offsets[3] = 71;
    offsets[4] = 72;
    offsets[5] = 73;
    offsets[6] = 74;
    offsets[7] = 75;
    offsets[8] = 76;
    offsets[9] = 77;
    offsets[10] = 78;
    offsets[11] = 79;
    offsets[12] = 80;
    offsets[13] = 81;
    offsets[14] = 84;
    offsets[15] = 85;
    offsets[16] = 86;
    offsets[17] = 87;
    offsets[18] = 120;
    offsets[19] = 121;
    offsets[20] = 122;
    offsets[21] = 123;
    offsets[22] = 124;
    offsets[23] = 125;
    offsets[24] = 126;
    offsets[25] = 127;
    offsets[26] = 129;
    offsets[27] = 1683;
    offsets[28] = 1687;
    offsets[29] = 1688;
    offsets[30] = 1691;
    offsets[31] = 1692;
    offsets[32] = 1693;
    offsets[33] = 1694;
    offsets[34] = 1695;
    offsets[35] = 1696;
    offsets[36] = 1697;
    offsets[37] = 1698;
    offsets[38] = 1699;
    offsets[39] = 1700;
    offsets[40] = 1701;
    offsets[41] = 1702;
    offsets[42] = 1703;
    offsets[43] = 1704;
    offsets[44] = 1705;
    offsets[45] = 1706;
    offsets[46] = 1707;
    offsets[47] = 1708;
    offsets[48] = 1709;
    while (true) {
        if (i > 0x30)
            break;
        type2Maze[offsets[i]/30][offsets[i]%30] = '*';
        i++;
    }
}

bool vis[100][100] = {false};

bool checkPos(int x, int y) {
    if (y % 3 == 0) {
        // type 0
        return type0Maze[x][y/3] == '*';
    } 
    else if (y % 3 == 1) {
        // type 1
        return type1Maze[64-x][y/3] == '*';
    }
    else {
        // type 2
        return type2Maze[x][y/3] == '*';
    }
}

int cnt = 0;
char currentPath[1000];

void dfs(int x, int y)
{
    if (vis[x][y])
        return;
    vis[x][y] = true;

    if (cnt > 521) {
        vis[x][y] = false;
        return;
    }
    
    if (x == 56 && y == 89) {
        for (int i = 0; i < cnt; i++)
            printf("%c", currentPath[i]);
        printf("\n");
        exit(0);
    }

    // w
    if (x > 1 && checkPos(x-2,y)) {
        currentPath[cnt++] = 'w';
        dfs(x-2, y);
        cnt--;
    }
    // a
    if (x <= 62 && checkPos(x+2,y)) {
        currentPath[cnt++] = 's';
        dfs(x+2, y);
        cnt--;
    }
    // s
    if (y >= 0 && checkPos(x,y-1)) {
        currentPath[cnt++] = 'a';
        if (y >= -1)
            dfs(x, y-1);
        else
            dfs(x, y-2);
        cnt--;
    }
    // d
    if (y <= 89 && checkPos(x, y+1)) {
        currentPath[cnt++] = 'd';
        if (y >= -1)
            dfs(x, y+1);
        else
            dfs(x, y+2);
        cnt--;
    }

    vis[x][y] = false;
}

int main() {
    initType2Maze();
    dfs(0, 0);
}
```

## easy_rust

rust 题目是一个 binggo 游戏，有特定的棋盘状态会触发后门来输出 flag，
前一段下的是 X，后一段下的是 O，并且中间不能有获胜的情况，
比较关键的是
```c
if ( someCount == 6 && maybe00 == 'X' && maybe11 == 'X' && !RCNotAllZero )
{
    v50 = '0';
    TARGET_CHAR = '0';
}
```
在第六次写 (0,0) 并且 (0,0)=X, (1,1)=X 的时候就会切换为 0，根据这个分析可以构造棋盘为：
X X 0
0 X X
X 0 0
对应序列
```
0 0
0 1
1 1
1 2
2 0
0 0
0 0
0 2
1 0
2 1
2 2
```
输出 `fductf{B0n_false10_000_t2b13}` <- flag

PS:
其实棋盘画成
X _ _
_ X _
0 0 0
对应序列
```
0 0
1 1
0 0
0 0
0 0
0 0
0 0
0 0
2 0
2 1
2 2
```
也能输出flag为 `fductf{B0n_true10_000_t2b13}`，但这个不是 flag，可能是因为没有填满吧。

## Paper-Scissors-Rock	（未解出）

似乎是 10000 次 rand() % 3 出来的 余0 余1 余2 的个数，但感觉还有东西没看到，解出 `fductf{3324_3315_3361_we1c0me}` 不对。